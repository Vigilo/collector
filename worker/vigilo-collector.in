#!/usr/bin/perl -w
# vim: set fileencoding=utf-8 sw=4 ts=4 et :
################################################################################
##
## vigilo-collector:  A script designed to improve performance for Vigilo's
##                    SNMP Collector with Nagios 4.x
## Copyright (C) 2017-2018 CS-SI
##
## This program is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License
## as published by the Free Software Foundation; either version 2
## of the License, or (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
################################################################################

package collector;

use strict;
use warnings;
use IO::Socket::UNIX;
use Time::HiRes qw( gettimeofday );
use IO::Capture::Stdout;
use IO::Capture::Stderr;
use Getopt::Long qw( GetOptions GetOptionsFromArray );
&Getopt::Long::config('bundling');
use Sys::CPU;
use Text::ParseWords qw( shellwords );
use Nagios::Plugin qw(%ERRORS);

use constant {
    LEVEL_WARN      => 0,
    LEVEL_INFO      => 1,
    LEVEL_NOTICE    => 2,
    LEVEL_DEBUG     => 3,
};

my $confdir = "@CONFDIR@";
my $jobs_count;
my $line;
my $pid;
my $socket;
my $max_jobs = 10000;
my $delay = 3;
my $gettimeofday;
my $testing = defined($ENV{'VIGILO_TEST'});
my ($help, $nagios_qh, $cpus, $verbose, $conf);
our ($lib, $path, $timeout, $nagios_cmd_file, $connector_socket, $tmppath);
my %job;

$nagios_qh = "/var/spool/nagios/cmd/nagios.qh";
$cpus = $testing ? 1 : 0;
$help = 0;
$verbose = LEVEL_WARN;

##################

sub print_help()
{
    my $cpus = Sys::CPU::cpu_count();

    print "\nUsage: $0 [options]\n";
    print "   -C (--conf)       Path to the Collector's configuration file\n";
    print "                     (defaults to $confdir/general.conf)\n";
    print "   -h (--help)       Print this help\n";
    print "   -v (--verbose)    Increase verbosity. Can be repeated up to 3 times.\n";
    print "   --cpus=N          Number of worker processes to start (default: $cpus)\n";
    print "   --nagios          Path to Nagios' query handler \n";
    print "                     (defaults to $nagios_qh)\n";
    exit(2);
}

sub runWorker {
    # Lors des tests, on veut obtenir des valeurs fixes
    # pour pouvoir facilement valider les résultats.
    $pid = $$;
    if ($testing) {
        $gettimeofday = sub { return (0, 0); };
    } else {
        $gettimeofday = \&gettimeofday;
    }

    RECONNECT:
    while (1) {
        $socket = IO::Socket::UNIX->new(
            Type => SOCK_STREAM,
            Peer => $nagios_qh,
        );

        if (!$socket) {
            print "[$pid] Could not connect to Nagios query handler ($nagios_qh)\n" if $verbose >= LEVEL_WARN;
            print "[$pid] Retrying in $delay second(s)...\n" if $verbose >= LEVEL_WARN;
            sleep($delay);
            next;
        }
        print "[$pid] Successfully connected to '$nagios_qh'\n" if $verbose >= LEVEL_WARN;

        $socket->autoflush(1);
        while (1) {
            # cf. https://assets.nagios.com/downloads/nagioscore/docs/Writing_a_Custom_Worker.pdf
            print "[$pid] Registering worker for plugin 'Collector'\n" if $verbose >= LEVEL_WARN;
            print $socket "\@wproc register name=vigilo-collector-$pid;pid=$pid;max_jobs=$max_jobs;plugin=Collector\0";
            {
                local $/ = "\0";
                $line = $socket->getline();

                if (!defined($line)) {
                    print "[$pid] Lost connection to Nagios query handler during registration. Reconnecting...\n" if $verbose >= LEVEL_WARN;
                    sleep($delay);
                    next RECONNECT;
                }

                if ($line ne "OK\0") {
                    print "[$pid] Could not register worker. Retrying...\n" if $verbose >= LEVEL_WARN;
                    sleep($delay);
                    next RECONNECT;
                }
            }

            print "[$pid] Ready to process jobs\n" if $verbose >= LEVEL_WARN;
            for ($jobs_count = 1; $jobs_count <= $max_jobs; $jobs_count++) {
                my @args;
                my $result;
                my $sec;
                my $usec;
                my $stdout;
                my $stderr;
                my $dummy;
                my $cmd_hostname;
                my ($cmd_state, $cmd_answer);

                {
                    local $/ = "\1\0\0\0";
                    $line = $socket->getline();
                }

                if (!defined($line)) {
                    print "[$pid] Lost connection to Nagios query handler. Reconnecting...\n" if $verbose >= LEVEL_WARN;
                    next RECONNECT;
                }

                %job = $line =~ /([^=]+)=([^\0]*)\0/gx;
                print "[$pid] Processing job #$jobs_count/$max_jobs (ID: $job{'job_id'}): $job{'command'}\n" if $verbose >= LEVEL_INFO;

                # Analyse du contenu de la commande en supprimant
                # le nom du plugin lui-même (/.../nagios/plugins/Collector).
                @args = shellwords($job{'command'});
                shift @args;

                GetOptionsFromArray(
                    \@args,
                    "V"   => \$dummy,           "version"    => \$dummy,
                    "h"   => \$dummy,           "help"       => \$dummy,
                    "d"   => \$dummy,           "debug"      => \$dummy,
                    "H=s" => \$cmd_hostname,    "hostname=s" => \$cmd_hostname,
                    "C=s" => \$dummy,           "conf=s"     => \$dummy,
                );

                delete $job{'command'};
                delete $job{'timeout'};

                ($sec, $usec) = $gettimeofday->();
                $job{'start'}       = sprintf("%d.%06d", $sec, $usec);
                $job{'exited_ok'}   = 1;
                $job{'wait_status'} = 0;
                $job{'outstd'}      = '';
                $job{'outerr'}      = '';

                {
                    no warnings 'once';

                    # Interception des appels à exit() et die().
                    BEGIN {
                        *CORE::GLOBAL::exit = sub {
                            my $status = shift;
                            print "Collector exited with status $status\n" if $verbose >= LEVEL_WARN;
                            $job{'wait_status'} = $status * 2 ** 8;
                        };
                        *CORE::GLOBAL::die = sub {
                            my $err = shift;
                            print "Collector exited with error: $err\n" if $verbose >= LEVEL_WARN;
                            $job{'outerr'} = $err;
                            $job{'wait_status'} = 3 * 2 ** 8;
                        };
                    }

                    # Capture STDOUT et STDERR.
                    $stdout = IO::Capture::Stdout->new();
                    $stderr = IO::Capture::Stderr->new();
                    $stdout->start();
                    $stderr->start();

                    # Exécute la collecte sur l'hôte.
                    ($cmd_state, $cmd_answer) = collect_host($cmd_hostname);
                    $job{'outstd'} = $cmd_answer;
                    $job{'wait_status'} = ${ERRORS{$cmd_state}} * 2 ** 8;

                    # Désactive le timer éventuellement restant.
                    alarm(0);

                    # Restaure les écritures sur STDOUT/STDERR.
                    $stdout->stop();
                    $stderr->stop();

                    # Récupère la sortie du collecteur.
                    $job{'outstd'} .= join(' ', $stdout->read());
                    $job{'outerr'} .= join(' ', $stderr->read());

                    # Remplacement des retours à la ligne dans les sorties
                    # par des espaces et suppression d'un éventuel espace final.
                    $job{'outstd'} =~ tr/\n/ /;
                    $job{'outstd'} =~ s/ $//;
                    $job{'outerr'} =~ tr/\n/ /;
                    $job{'outerr'} =~ s/ $//;

                    print "[$pid] STDOUT: $job{'outstd'}\n" if $verbose >= LEVEL_NOTICE;
                    print "[$pid] STDERR: $job{'outerr'}\n" if $verbose >= LEVEL_NOTICE;
                };

                ($sec, $usec) = $gettimeofday->();
                $job{'stop'}        = sprintf("%d.%06d", $sec, $usec);
                $job{'runtime'}     = sprintf("%.6f", $job{'stop'} - $job{'start'});

                $result = join("\0", map{qq{$_=$job{$_}}} keys %job) . "\0\1\0\0\0";
                print "[$pid] Processed job #$jobs_count/$max_jobs (ID: $job{'job_id'}): $job{'start'} - $job{'stop'} ($job{'runtime'}s) [result: $job{'wait_status'}]\n" if $verbose >= LEVEL_INFO;
                print $socket $result;

                # Lors des tests, on n'exécute qu'un seul job avant de quitter.
                if ($testing) {
                    exit(0);
                }
            }
        }
    }
}

##################

GetOptions(
    'help|?'        => \$help,
    'nagios=s'      => \$nagios_qh,
    'cpus=i'        => \$cpus,
    'verbose+'      => \$verbose,
    'v+'            => \$verbose,
    'conf=s'        => \$conf,
    'C=s'           => \$conf,
);

if ($help) {
    print_help();
}

if ($cpus <= 0) {
    $cpus = Sys::CPU::cpu_count();
}

unless (defined $conf) {
    $conf = "$confdir/general.conf";
}

## Load the main configuration file
do $conf;

if (! $lib) {
    print "Provide a pathname for the library directory\n";
    exit(2);
} elsif (! -x $lib) {
    print "Provide an existing library path: $lib\n";
    exit(2);
}

require "$lib/collector.pm";
check_conf();
load_libs(($verbose >= LEVEL_DEBUG) ? 1 : 0);

print "[$$] Manager is starting\n" if $verbose >= LEVEL_WARN;
for (1 .. $cpus) {
    $pid = fork;
    if (not defined $pid) {
        warn "[$$] Could not fork" if $verbose >= LEVEL_WARN;
        next
    }
    if (not $pid) {
        runWorker;
    } else {
        print "[$$] Forked worker with PID $pid\n" if $verbose >= LEVEL_WARN;
    }
}

for (1 .. $cpus) {
    $pid = wait();
    print "[$pid] Worker exited\n" if $verbose >= LEVEL_WARN;
}
print "[$$] Manager is exiting\n" if $verbose >= LEVEL_WARN;
